#!/usr/bin/python3

import os
import sys
import time
from signal import signal, SIGINT
import random
import requests
import subprocess

red = '\033[31m'
green = '\033[32m'
orange = '\033[33m'
blue = '\033[34m'
purple = '\033[35m'
cyan = '\033[36m'
lightgrey = '\033[37m'
darkgrey = '\033[90m'
lightred = '\033[91m'
lightgreen = '\033[92m'
yellow = '\033[93m'
lightblue = '\033[94m'
pink = '\033[95m'
lightcyan = '\033[96m'


def color(*args):
    colors = [red, green, orange, blue, purple, cyan,
             lightgreen, lightred, yellow, pink, darkgrey]
    if args:
        args, = args
        return args
    else:
        return random.choice(colors)


class fc:
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    ENDC = '\033[0m'


def sudo():
    if not os.geteuid() == 0:
        sys.exit(color() + "I'm affraid I need some superuser privilages, start with 'sudo'" + fc.ENDC)


def handler(signal_received, frame):
    print(color() + fc.BOLD + "\nCTRL-C detected. Exiting.... ")
    exit(0)


if __name__ == '__main__':
    signal(SIGINT, handler)


def logo():

    logo = r'''

_____   __           _____
___  | / /________  ___  /____________________
__   |/ /_  _ \  / / /  __/_  ___/  __ \_  __ \
_  /|  / /  __/ /_/ // /_ _  /   / /_/ /  / / /
/_/ |_/  \___/\__,_/ \__/ /_/    \____//_/ /_/
'''

    wordsalads = ["Freedom's just another word for missing someone.", "The quieter you become the more you are able to hear.",
                  "It's good to be different but never belittle that angel on your shoulder.",

                  "Good love will find you.", "My heart is beating a little extra today.",
                  """Smile with all your teeth :)""", "This is a just reminder that you're strong, beautiful and worthy of love.",
                  "Treat every women like a princess.", "Never take the fact that you're a good listener as granted.",
                  "Don't think too much, it'll hurt your head.", "You may loose a lot of battles but never loose the sight of the war.",
                  "Love is a dance.."
                  ]

    wordsalad = random.choice(wordsalads)
    print(color() + fc.BOLD + logo + fc.ENDC, flush=True)
    print(color() + fc.BOLD + wordsalad.strip("\n") + fc.ENDC)


def ip():
    try:
        ip_ = requests.get('https://icanhazip.com/').text
    except requests.exceptions.RequestException:
        try:
            ip1 = requests.get('https://ipinfo.io/ip').text
            return ip1
        except requests.exceptions.RequestException as e:
            print(f'\n{e}')
            sys.exit(color() + """\nSorry, can't fetch the deets.
Either the site's down or something's up with your internet-config.

you may found the solution here :)
https://github.com/Feliz-SZK/Linux-Decoded/blob/master/Fix%20temporary%20failure%20in%20name%20resolution.md""" + fc.ENDC)


    return ip_


def returnNotMatches(a, b):
    a = set(a)
    b = set(b)
    return (a-b)


def frag():
    fragment = subprocess.Popen("iptables -t nat -L -n | grep 5353", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True).communicate()
    frag, defrag = fragment
    if defrag: print(f"\n{red}encounterd some hiccups while checking the iptables-deets{fc.ENDC}")
    return frag.decode("utf-8")

def finesse(backoff, resolv_switch):

    if backoff > 5:
        sys.exit(
            f"\n{color(red)}excceeded no of retries, terminating to prevent memory corruption.{fc.ENDC}")

    if not os.path.exists('/etc/resolv.conf'):
        print(f"\n{color(lightblue)}resolv.conf file is missing,", end=" ")
        askin = str(input(
            f"{color(lightblue)}you want me to manually create it for ya! {lightgreen}Y/N: {fc.ENDC}")).lower().strip()

        if askin == 'y':
            try:
                with open("/etc/resolv.conf", "w") as f:
                    f.write("nameserver 127.0.0.1")
                resolv_switch += 1
                print(f"{color()}Done, saved with local dns.{fc.ENDC}")
            except Exception as e:
                print(
                    f"{color(red)}something's wrong, can't write the file.{fc.ENDC}\n{e}")
        elif askin == "n":
            sys.exit(f"{color(green)}Roger that, terminating....{fc.ENDC}")
        else:
            backoff += 1
            return finesse(backoff, resolv_switch)
    return resolv_switch


torrstring = ["User tor", "VirtualAddrNetworkIPv4 10.192.0.0/10", 'AutomapHostsOnResolve 1',
              'TransPort 9040', 'DNSPort 5353', 'CookieAuthentication 1', 'ControlPort 9051', "DataDirectory /var/lib/tor"]


resolvstring = 'nameserver 127.0.0.1'


def resolv_config(r_switch):
    if r_switch == 0:
        with open('/etc/resolv.conf') as f:
            lines = f.read().splitlines()

        if resolvstring not in lines:
            print(green + fc.BOLD + "Configuring resolv.conf" + fc.ENDC)
            time.sleep(0.4)
            os.system(
                    "cp /etc/resolv.conf /etc/resolv.conf.backup_neutron")
            with open('/etc/resolv.conf', 'w') as rconf:
                rconf.write("%s\n" % resolvstring)
            print(color(lightred) + "DONE :)" + fc.ENDC)
        else:
            if resolvstring in list(filter(lambda rc: 'nameserver' in rc, lines))[0]:
                print(green + fc.BOLD + "Configuring Resolv.config" + fc.ENDC)
                time.sleep(0.4)
                print(color() + fc.BOLD + """ :) Already Configured""" + fc.ENDC)
                time.sleep(0.5)
            else:
                print(green + fc.BOLD + "Configuring resolv.conf" + fc.ENDC)
                os.system(
                    "cp /etc/resolv.conf /etc/resolv.conf.backup_neutron")
                with open('/etc/resolv.conf', 'w') as rconf:
                    rconf.write("%s\n" % resolvstring)
                print(color(lightred) + "Done...." + fc.ENDC)
    else:
        print(green + fc.BOLD + "Configuring Resolv.config" + fc.ENDC)
        time.sleep(0.4)
        print(color() + " :) Already Configured" + fc.ENDC)

    return 0


def configure():

    if "neutron" in frag(): sys.exit(f"\n{lightblue}neutron is already running....{fc.ENDC}")

    r_switch = finesse(0, 0)

    if os.system("which tor > /dev/null") == 0:
    
        if not os.path.exists('/etc/tor/torrc'):
            print(
                f"{color(red)}No torrc file is configured.....{fc.ENDC}{color(green)}Configuring:)")
            try:
                f = open('/etc/tor/torrc', 'w+')
                for elements in torrstring:
                    f.write("%s\n" % elements)
                f.close()
                print(f"{color(cyan)}Done....{fc.ENDC}")
            except Exception as e:
                print(f"{color(red)}Failed to write the torrc file{fc.ENDC} \n {e}")
                sys.exit()
        else:
            print(f"\n{color(green)}{fc.BOLD}Configuring Torrc {fc.ENDC}")
            time.sleep(0.4)

            with open('/etc/tor/torrc') as x:
                verse = x.read().splitlines()

            subprocess.Popen(["cp", "/etc/tor/torrc", "/etc/tor/torrc.bak_neutron"], stdout=subprocess.PIPE).communicate()
            torrc = open('/etc/tor/torrc', 'w')
            for elements in torrstring:
                torrc.write("%s\n" % elements)
            torrc.close()
            print(f"{color(lightred)}DONE :){fc.ENDC}")

    else:
        print(f'''\n{color(red)}tor isn't installed, install it with
'sudo pacman -S tor'{fc.ENDC}''')
        sys.exit()

    subprocess.Popen(['systemctl', 'restart', 'tor'])

    resolv_config(r_switch)



def terminate():

    trigger = 0
    if os.path.exists('/etc/resolv.conf.backup_neutron'):
        trigger += 1
        restore = "yes | mv /etc/resolv.conf.backup_neutron /etc/resolv.conf"
        process = subprocess.Popen('/bin/bash', stdin=subprocess.PIPE,
                                   stdout=open(os.devnull, 'wb'), stderr=subprocess.PIPE)
        print(f"\n{green}{fc.BOLD}reverting to default resolv.conf{fc.ENDC}")
        out, err = process.communicate(restore.encode('utf-8'))

        if err:
            print('\n' + err.decode('utf8').replace("\n", '\n'))
            print(" ")
            print(red + r'''I guess you're playing around,
else your system has some serious paranoia(deleting backups itself)''' + fc.ENDC)
            sys.exit()
        time.sleep(0.5)
        print(f"{cyan}{fc.BOLD}[Complete]{fc.ENDC}")
    
    if os.path.exists('/etc/tor/torrc.bak_neutron'):
        trigger += 1
        torrc_restore = "mv /etc/tor/torrc.bak_neutron /etc/tor/torrc"
        process = subprocess.Popen('/bin/bash', stdin=subprocess.PIPE,
                                   stdout=open(os.devnull, 'wb'), stderr=subprocess.PIPE)
        print(f"{green}{fc.BOLD}dropping of torrc file{fc.ENDC}")
        out, err = process.communicate(torrc_restore.encode('utf-8'))

        if err:
            print('\n' + err.decode('utf8').replace("\n", '\n'))
            print(" ")
            print(green + r'''I guess you're playing around, 
else your system has some serious paranoia(deleting backups itself)''' + fc.ENDC)
            sys.exit()
        time.sleep(0.5)
        print(f"{cyan}{fc.BOLD}[Done]{fc.ENDC}")
    if "neutron" in frag():
        trigger += 1
        restore_iptables = '''
        iptables -P INPUT ACCEPT
        iptables -P FORWARD ACCEPT
        iptables -P OUTPUT ACCEPT
        iptables -t nat -F
        iptables -t nat -X
        iptables -t mangle -F
        iptables -t mangle -X
        iptables -F
        iptables -X
        systemctl stop tor
        '''
        print(green + fc.BOLD + 'Restoring Iptables rules' + fc.ENDC)
        process1 = subprocess.Popen(
            '/bin/bash', stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out1, err1 = process1.communicate(restore_iptables.encode('utf-8'))

        time.sleep(0.5)
        if err1:
            print(color() + '\n' + err1.decode('utf8').strip() + fc.ENDC)
            print(color() + "Can't restore Iptables")
        time.sleep(0.5)

    if trigger == 0:
        print('\n' + red + fc.BOLD + "No instances of Neutron has been executed")
        print(green + fc.BOLD + '[Exiting...]' + fc.ENDC)
        sys.exit()
    else: print(color() + fc.BOLD + 'Cleaning up complete :)' + fc.ENDC)


def torcircuit():

    if not "neutron" in frag():
        print('\n' + color() + 'You gotta start Neutron first' + fc.ENDC)
        sys.exit()
    else:
        subprocess.Popen(["systemctl", "reload", "tor"])
        print(green + "\nSrambling Tor Nodes" + fc.ENDC)
        time.sleep(0.4)
        print(color() + fc.BOLD + "DONE :)" + fc.ENDC)
        time.sleep(0.4)
        print(green + "Your new ip appears to be: " +
              fc.ENDC + color() + fc.BOLD + str(ip()) + fc.ENDC)


def tor_stat(e_backoff):

    if e_backoff > 0:
        sys.exit(color() + """\nSorry, can't fetch the deets.
Either the site's down or something's wrong with your internet config.

you may found the solution here :)
https://github.com/Feliz-SZK/Linux-Decoded/blob/master/Fix%20temporary%20failure%20in%20name%20resolution.md""" + fc.ENDC)

    ip = r'''
deets=$(curl https://check.torproject.org -s -k); echo $deets | grep -o "<title>[^<]*" | tail -c+8; echo $deets | grep -o -m1 "[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}" 
'''
    process1 = subprocess.Popen(
        '/bin/bash', stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out1, err1 = process1.communicate(ip.encode('utf-8'))
    if len(out1.decode('utf8')) == 0:
        e_backoff += 1
        print(f"{color()}\nhaving trouble fetching exit-node details, retrying....{fc.ENDC}")
        time.sleep(1)
        return tor_stat(e_backoff)
    else:
        deet = out1.decode("utf-8").strip().split('\n')
        print("\nYour Ip address is: " + color() + fc.BOLD + deet[1] + fc.ENDC)
        print(f"{color()}Congratulations, you're using tor :){fc.ENDC}") if "Congratulations" in deet[0].strip(
        ) else print(f"{color()}{deet[0].strip()}{fc.ENDC}")
    return 0


def firewall():

    inn_out_rules = '''
            
    trans_port="9040"
    non_tor="127.0.0.0/8 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16"

    iptables -F
    iptables -t nat -F

    # nat dns requests to Tor
    iptables -t nat -A OUTPUT -m owner --uid-owner tor -j RETURN
    iptables -t nat -A OUTPUT -p udp --dport 53 -j REDIRECT --to-ports 5353 -m comment --comment "neutron_triggered"
    iptables -t nat -A OUTPUT -p tcp --dport 53 -j REDIRECT --to-ports 5353
    iptables -t nat -A OUTPUT -p udp -m owner --uid-owner tor -m udp --dport 53 -j REDIRECT --to-ports 5353
    
    # resolve .onion domains mapping 10.192.0.0/10 address space to access hidden services
    iptables -t nat -A OUTPUT -p tcp -d 10.192.0.0/10 -j REDIRECT --to-ports 9040
    iptables -t nat -A OUTPUT -p udp -d 10.192.0.0/10 -j REDIRECT --to-ports 9040
    
    # exclude local addresses
    for NET in $non_tor 127.0.0.0/9 127.128.0.0/10; do
        iptables -t nat -A OUTPUT -d $NET -j RETURN
    done
    
    # redirect all other output through TOR transport
    iptables -t nat -A OUTPUT -p tcp --syn -j REDIRECT --to-ports $trans_port
    iptables -t nat -A OUTPUT -p udp -j REDIRECT --to-ports $trans_port
    iptables -t nat -A OUTPUT -p icmp -j REDIRECT --to-ports $trans_port
    
    # accept already established connections
    iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    
    # exclude local addresses
    for NET in $non_tor 127.0.0.0/8; do
        iptables -A OUTPUT -d $NET -j ACCEPT
    done
    
    # allow only tor output
    iptables -A OUTPUT -m owner --uid-owner tor -j ACCEPT
    iptables -A OUTPUT -j REJECT

    '''

    process5 = subprocess.Popen('/bin/bash', stdin=subprocess.PIPE,
                                stdout=open(os.devnull, 'wb'), stderr=subprocess.PIPE)
    out5, err5 = process5.communicate(inn_out_rules.encode('utf-8'))


    if err5:
        print('\n' + color() + err5.decode('utf8').strip() + fc.ENDC)
        print("""There's something strange with your system
It doesn't let me change the iptable rules""")
        sys.exit()
    time.sleep(1)


def usage():

    banner = """
                       _ ._  _ , _ ._
                     (_ ' ( `  )_  .__)
                   ( (  (    )   `)  ) _)
                  (__ (_   (_ . _) _) ,__)
                      `~~`\ ' . /`~~`
                      ,::: ;   ; :::,
                     ':::::::::::::::'
 _________________________/_ __ \_________________________
|                                                         |
| 1.Start Neutron        --type in Neutron Start          |
| 2.Stop neutron         --type in Neutron Stop           |
| 3.Check ip             --type in Neutron myip           |
| 4.Change Tor Circuit   --type in Neutron shuffle        |
| 5.Check Tor Config     --type in Neutron check          |
| (start,stop,myip,shuffle,config are Non-case sensitive) |
|_________________________________________________________|

"""

    print(color() + banner + fc.ENDC)


arg = sys.argv[1:]

if len(arg) != 1:
    usage()
elif sys.argv[1].casefold() == 'start'.casefold():
    sudo()
    logo()
    configure()
    firewall()
    tor_stat(0)
elif sys.argv[1].casefold() == 'stop'.casefold():
    sudo()
    logo()
    terminate()
elif sys.argv[1].casefold() == 'myip'.casefold():
    logo()
    print('\n' + green + 'your ip is: ' + fc.ENDC + color() + ip() + fc.ENDC)
elif sys.argv[1].casefold() == 'shuffle'.casefold():
    sudo()
    logo()
    torcircuit()
elif sys.argv[1].casefold() == 'check'.casefold():
    logo()
    tor_stat(0)
else:
    print(
        f"{color(lightgreen)} {sys.argv[1]}! {color(lightblue)}ain't a valid trigger. {fc.ENDC}")
    usage()
